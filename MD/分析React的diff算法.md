# 分析React的diff算法

React最让人称道的，除了函数式编程模型。就是其高效的`Virtual DOM`模型与`diff`的完美结合。 

>   Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）[@戴嘉华](https://segmentfault.com/a/1190000004029168)


### 一、React中的Virtual DOM
话说为什么要用`Virtual DOM`来模拟DOM树的渲染呢？它如此复杂。Reddit上的 [ugwe43to874nf4](https://www.reddit.com/user/ugwe43to874nf4) 对Virtual DOM的重要性做了更客观的评价。

>   DOM 操作 真正的问题在于每次操作都会触发布局的改变、DOM树的修改和渲染。所以，当你一个接一个地去修改30个节点的时候，就会引起30次（潜在的）布局重算，30次（潜在的）重绘，等等。

>   Virtual DOM 实际上没有使用什么全新的技术，仅仅是把 “ 双缓冲（double buffering）” 技术应用到了DOM上面。
这样一来，当你在这个单独的虚拟的DOM树上也一个接一个地修改30个节点的时候，它不会每次都去触发重绘，所以修改节点的开销就变小了。
之后，一旦你要把这些改动传递给真实DOM，之前所有的改动就会整合成一次DOM操作。这一次DOM操作引起的布局计算和重绘可能会更大，但是相比而言，整合起来的改动只做一次，减少了（多次）计算。

>   不过，实际上不借助Virtual DOM也可以做到这一点。你可以自己手动地整合所有的DOM操作到一个DOM 碎片（DOM fragment） 里，然后再传递给DOM树。

>   既然如此，我们再来看看Virtual DOM到底解决了什么问题。
首先，它把管理DOM碎片这件事情自动化、抽象化了，使得你无需再去手动处理。另外，当你要手动去做这件事情的时候，你还得记得哪些部分变化了，哪些部分没变，毕竟之后重绘时，DOM树上的大量细节你都不需要重新刷新。这时候Virtual DOM的自动化对你来说就非常有用了，如果它的实现是正确的，那么它就会知道到底哪些地方应该需要刷新，哪些地方不要。

>   最后，Virtual DOM通过各种组件和你写的一些代码来请求对它进行操作，而不是直接对它本身进行操作，使你不必非要跟Virtual DOM交互，也不必非要去了解Virtual DOM修改DOM树的原理，也就不用再想着去修改DOM了。（译注：对开发者来说，Virtual DOM几乎是完全透明的）。这样你就不用在 修改DOM 和 整合DOM操作为一次 之间做同步处理了。

看完大佬的解答，是不是对`Virtual DOM`的必要性有了一定了解。`Virtual DOM`必然比不上我们手动的优化dom操作。但是在页面复杂，项目巨大，前端工程化的前提下，我们很难做到**处处手动优化dom操作**。而引入了`Virtual DOM`就能使一切dom完全自动，开发者完全不必跟dom对话，随心所欲的更新视图，它也能够给我们提供不错的性能。

这其实是我们采用一些“看似”没必要的方案的缘由

完整的`Virtual DOM 算法`包括以下几个步骤：
-   1.用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中
-   2.当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
-   3.把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了


### 二、diff算法
`Virtual DOM`的高效得益于一套完善的`diff`算法。试想我们每次更新data产生都产生新的dom树，如果完全不加修饰的“吐”到页面上，那实际效果还不如“原始”的dom操作呢。

引入diff算法，为每次变化的`Virtual DOM Tree`找出更新的节点，把这些变化渲染到页面上。

### 三、传统diff算法的弊端
我们知道，针对树形结构的传统diff算法时间复杂度高达`O(n^3)`。如是针对dom树的比较采用这样的方法，效率未免太低了，直接操作dom都比这好。前端渲染场景肯定接受不了这样的性能消耗。

所以传统diff不可取，React要想实现`Virtual DOM`必须得对现有方法进行从头到脚的优化。

### 四、React中的diff算法
于是便有了如今的diff，时间复杂度仅为`O(n)`，从指数级变为了常数级，有了质的飞跃。

React抛弃了一些web端不常见的场景，使用了以下3个策略

##### 策略一：Web UI 中 DOM 节点跨级移动操作特别少，可以忽略不计。
通常我们在进行dom编程的时候，并不会出现跨层级的节点移动。所以React在进行diff时，`每个节点就只会针对其同级节点进行比较`。如图：

![dom节点](https://segmentfault.com/image?src=http://livoras.github.io/blog/virtual-dom/compare-in-level.png&objectId=1190000004029168&token=314c5643bfbf5b864c0de6a4276af7c3/view)

如果发现节点消失时，会直接在删除该节点及其子节点，不再浪费时间。如此几乎只要扫描一次就能够完成所有节点的遍历。

**假如真的发生了跨级节点移动的话**，React在扫描时发发现b层节点多了，就创建他。发现a层节点少了，就删除他。例如：

![dom层级变换](https://github.com/w771854332/bengiBlog-node/blob/master/public/screenshot/dom%E5%B1%82%E7%BA%A7%E5%8F%98%E6%8D%A2.png?raw=true)

此时，diff 的执行顺序为：create A → create B → create C → delete A。
>   diff应该是先执行创建任务再执行删除的


##### 策略二：拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。

-   1.同一类型的组件，按照原策略继续比较`Virtual Dom`树
-   2.若不是同一类型的组件，之间判断是否为`dirty Component`，若是，直接重新渲染
-   3.对于同一类型的组件。开发者可提供`shouldComponentUpdate`来告诉React是否需要进行diff分析比较。

>   合理的设置shouldComponentUpdate可以大幅度提高性能
##### 策略三：对于同一层级的一组子节点，它们可以通过唯一key进行区分。
对于同一层级的节点，提供了三种节点操作：
-   1.INSERT_MARKUP 插入

未完待续...
