# 原型浅析

## 前言
-   1.所有对象都有`__proto__`属性，称作隐式原型。指向他的构造函数的`prototype`，这个`prototype`的值也是对象。同样也就具有`__proto__`
-   2.只有函数具有`prototype`，但函数本身同样也是对象，所以也有`__proto__`，所有函数的`__proto__`都指向大Function.`prototype`，包括Object。
>   这就可以说明所有对象都是由函数创建的。

还可以参考：
```javascript
    var a = {}
    // 等同于
    var a = new Object()

    function Foo(){}
    // 等同于
    var Foo = new Function()
```
同样可以说明问题。

所以
```javascript
    Function.__proto__ === Function.prototype
    Function.prototype.__proto__ === Object.prototype
    Object.prototype.__proto__ === null
```
## instanceof
instanceof单词字面意思是   从..继承
例如 a instanceof b，会沿着a的`__proto__`向上找，(假如a = new A()), 寻找路径为：
```javascript
    a.__proto__   ->  A.prototype.__proto__ -> Object.prototype
```

这边沿着b的`prototype`这条线，同时开始查找.....寻找路径为：
```javascript
    b.prototype
```

假如两边能查找到同一个对象，instanceof就会返回true， 否则就为false

>   ps: instanceof 右边只能为函数（必须得有`prototype`，单纯的对象没有`prototype`），不然会报错。

### 继承
es5中实现继承的方法。
```javascript
    function A(){
        this.name =  "I'm A";
    }


    function B(){}
    B.prototype = new A();
    B.prototype.constructor = B;
```
此时B就算继承了A，这时候我们
```javascript
    var b = new B();
    b.name // I'm A
```

这种继承方法的原理实际上是，利用了**原型链**的特性，一个对象在取属性的时候，会先在自身的实例中寻找该属性，如果找不到的话，就上`__proto__`里面找，如果还找不到，就一直往上找。

我们现在把方法都写到了原型里

