# 尾调用、尾递归


[尾调用优化 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2015/04/tail-call.html)



### 一、传统递归
递归对内存的消耗特别严重，在一个正常的递归函数中如：

```javascript
  var i = 0;
  function foo(){
    i ++;
    if (i <= 100){
      foo()
    }
  }
```

递归在执行结束之前，第一个触发的foo函数永远处于执行状态。  
当foo函数执行一次，调用记录就会被保存一次。只有当递归结束时，这个函数才算走到了终点，这些记录才会被清除。  


对于计算量特别大的递归函数，很容易发生"栈溢出"错误.

### 二、尾调用（Tail Call）

```javascript
  function foo(){
    return bar()
  }
```

如上，把函数调用放在函数的结尾（return）处。省去了声明中间变量。  

尾调用的重要性在于他可以不在调用栈添加一个新的堆栈帧，而是更新他，迭代也是一样的效果。

看来尾递归优化的代码，是能够达到一种较高的性能并且保持原本的语义化。


### 三、尾递归

于是我们得到了可以根据递归的最佳实践。我们把传统递归函数用"尾递归"优化。
```javascript
  function foo(i){
    return i <= 100 ? foo(++i) : i;
  }
```

就能够得到较大的性能提升。  

通常对递归函数的转换方法，需要把递归函数中所有用到的变量都作为参数传入。  