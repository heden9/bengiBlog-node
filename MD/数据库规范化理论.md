# 数据库规范化理论

### 函数依赖（Functional Dependency）
所有`关系实例`都必须要满足的约束条件
```
Sname = f(Sno) 记为 Sno → Sname
```

如果X → Y，但Y ∉ X，则称X → Y是`非平凡的函数依赖`
若X → Y，但Y ⊆ X，则称X → Y是`平凡的函数依赖`

```
例：在关系SC(Sno, Cno, Grade)中，
非平凡函数依赖： (Sno, Cno) → Grade
平凡函数依赖：   (Sno, Cno) → Sno
                (Sno, Cno) → Cno
```

1.  完全函数依赖
Sno → Sname
2.  部分函数依赖
(Sno, Sname) → Sdept
3.  传递函数依赖
### 多值依赖（Multivalued Dependency）

### 现实社会中的函数依赖关系

```
F ＝｛ Sno → Sdept,  Sdept → Mname, (Sno, Cname) → Grade ｝
```

### 不合理的关系模型中存在的问题
1.  数据冗余
2.  更新异常
3.  删除异常
删除记录时会将不想删除的数据删除
4.  插入异常
新增记录时需要给定未知的数据

### 关系规范化理论
 关系型数据库中的数据是要满足一定要求的，满足不同程度的要求被称为不同的`范式`。
 通过`分解关系模式`来消除其中不合适的数据依赖。

 ### 范式

 1. 1NF的定义为：符合1NF的关系中的每个属性都不可再分，什么是属性不可再分？ 如下图
![](https://pic4.zhimg.com/50/24afd11455ac34a280fa83e4e8d75ccc_hd.jpg)
进价和销售就是一个可在分的属性，故不满足第一范式
2.  2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。
3.  3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。
4.  BCNF在3NF的基础上消除主属性对于码的部分与传递函数依赖。
5.  4NF在3NF的基础上，消除表中的多值依赖。


### 三级封锁协议
1.  一级封锁协议，在修改时加x锁
可以防止丢失修改
2.  二级封锁协议，在一级封锁协议的基础上。在读时加r锁，读完即释放
可以防止丢失修改，读脏数据
3.  三级封锁协议，在二级封锁协议的基础上。当事务完成够才释放r锁
丢失修改、读脏数据和不可重复读。
