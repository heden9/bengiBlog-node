## TCP/IP 协议族
#### 1.分层管理
* 应用层 HTTP、DNS、FTP


* 传输层 TCP、UDP、RTP、SCTP

  传输层对上层应用层，提供网络连接中的两台计算机之间的数据传输。
* 网络层 IP

* 数据链路层（网络接口层）物理设备

对应OSI七层模型
#### 2.TCP/TP通信传输流
![tcpip通信传输流](https://github.com/w771854332/bengiBlog-node/blob/master/public/screenshot/tcpip通信传输流.png)


*   发送端
  在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息

*   接收端
  每经过一层时会把对应的首部消去

![tcpip封装](https://github.com/w771854332/bengiBlog-node/blob/master/public/screenshot/tcpip封装.png)

## IP、TCP、DNS
IP协议的作用是把各种数据包传送给对方，而且要保证确实传送到对方那里。采用的两个重要条件是***IP地址*** 和 ***MAC地址***

IP地址可能经常更改，但MAC地址永远不会变，被固化在网卡中。

在通信过程中，通信双方通常需要经过多台计算机和网络设备中转才能连接到对方。这时候就依赖ARP协议进行通信

***ARP协议（Address Resolution Protocol）。地址解析协议，根据通信双方的IP地址就能够反查出对呀的MAC地址。***

### 确保可靠的TCP协议

#### 1.三次握手（three-way handshaking）
  握手中采用两种标志位，SYN（synchronize同步 和ACK（acknowledgement确认

  1.客户端先发送带有SYN标志位的数据包给服务端。
  2.服务端接受到该数据包，发送带有 SYN/ACK 的数据包。
  3.客户端接收到回应，发送带有ACK的数据包。

  三次握手结束。

### 负责域名解析的DNS服务
  提供通过域名查找IP或者，逆向从IP反查出域名的服务。

### 经典问题，在地址栏输入一个地址，发生了什么。
[参考1](https://www.jianshu.com/p/69c2cf84b407)
[参考2](https://www.jianshu.com/p/5b069ae8c4f2)
查询ip地址的步骤：

  1.浏览器解析出url中的域名。
  2.查询浏览器的DNS缓存。
  3.浏览器中没有DNS缓存，则查找本地客户端hosts文件有无对应的ip地址。
  4.hosts中无，则查找本地DNS服务器（运营商提供的DNS服务器）有无对应的DNS缓存。
  5.若本地DNS没有DNS缓存，则向根服务器查询，进行递归查找。
  6.递归查找从顶级域名开始（如.com）,一步步缩小范围，最终客户端取得ip地址

tcp连接与http连接：

  1.http协议建立在tcp协议之上，http请求前，需先进行tcp连接，形成客户端到服务器的稳定的通道。俗称TCP的三次握手
  2.tcp连接完成后，http请求开始，请求有多种方式，常见的有get，post等。
  3.http请求包含请求头，也可能包含请求体两部分，请求头中包含我们希望对请求文件的操作的信息，请求体中包含传递给后台的参数。
  4.服务器收到http请求后，后台开始工作，如负载平衡，跨域等，这里就是后端的工作了。
  5.文件处理完毕，生成响应数据包，响应也包含两部分，响应头和相应体，响应体就是我们所请求的文件。
  6.经过网络传输，文件被下载到本地客户端，客户端开始加载。

html渲染：

  1.客户端浏览器加载了html文件后，由上到下解析html为DOM树（DOM Tree）。
  2.遇到css文件，css中的url发起http请求。
  3.这是第二次http请求，由于http1.1协议增加了Connection: keep-alive声明，故tcp连接不会关闭，可以复用。
  4.http连接是无状态连接，客户端与服务器端需要重新发起请求--响应。
  5.在请求css的过程中，解析器继续解析html，然后到了script标签。
  6.由于script可能会改变DOM结构，故解析器停止生成DOM树，解析器被js阻塞，等待js文件发起http请求，然后加载。这是第三次http请求。js执行完成后解析器继续解析。
  7.由于css文件可能会影响js文件的执行结果，因此需等css文件加载完成后再执行。
  8.Render Tree会被css文件阻塞，渲染树生成后，先布局，绘制渲染树中节点的属性(位置，宽度，大小等)，然后渲染，页面就会呈现信息。
  9.继续边解析边渲染，遇到了另一个js文件，js文件执行后改变了DOM树，渲染树从被改变的dom开始再次渲染。
  10.继续向下渲染，碰到一个img标签，浏览器发起http请求，不会等待img加载完成，继续向下渲染，之后再重新渲染此部分。
  11.DOM树遇到html结束标签，停止解析，进而渲染结束。


### URL和URI
URL： 统一资源定位符
URI： 统一资源标识符


## HTTP请求
可使用Linux 下 curl命令模拟请求
```bash
    curl -I www.baidu.com
```
从客服端发送到服务端的请求报文

```bash
    > GET / HTTP/1.1  # [方法] [URI] [协议版本]
    > Host: www.baidu.com # 主机名
    > User-Agent: curl/7.54.0 # ua
    > Accept: */*
```
输出请求头信息
```bash
    HTTP/1.1 200 OK
    Server: bfe/1.0.8.18
    Date: Tue, 06 Mar 2018 04:59:00 GMT
    Content-Type: text/html
    Content-Length: 277
    Last-Modified: Mon, 13 Jun 2016 02:50:08 GMT
    Connection: Keep-Alive
    ETag: "575e1f60-115"
    Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
    Pragma: no-cache
    Accept-Ranges: bytes
```

### http的特性
1.无状态
2.可靠
3.面向连接

## http首部字段

If-xxx的条件请求。服务器判定条件为真时，执行请求。
*   If-Match
![if-match](https://github.com/w771854332/bengiBlog-node/blob/master/public/screenshot/if-match.png)
他会告知服务器匹配资源所用的实体标记（ETag）值。此时的服务器无法使用弱ETag值。
当且仅当If-Match的字段亿资源匹配时，服务器才会返回200， 否则返回412

*   If-Modified-Since
![if-modified-since](https://github.com/w771854332/bengiBlog-node/blob/master/public/screenshot/if-modified-since.png)
如果在If-Modified-Since指定的日期之后，服务器上的资源发生了变化，则服务器会接受请求，否则就返回304 Not Modified
*   If-None-Match
![if-none-match](https://github.com/w771854332/bengiBlog-node/blob/master/public/screenshot/if-none-match.png)
客户端在发送请求的时候，
*   If-Range
*   If-Unmodified-Since
