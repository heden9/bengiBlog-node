### 为什么要进行数据交换？

#### N^2链路问题
n台主机之间要进行数据交换，如果采用主机与主机之间直接相连的方式，需要 N(N-1)/2的线路，所需成本会随着主机数量增加而急剧上升。

所以引入了‘数据交换设备’的概念。

![](https://github.com/w771854332/bengiBlog-node/blob/master/public/screenshot/交换设备.png?raw=true)

1.动态转接

将一个端口的数据转发到另一个端口

1.电路交换

最典型的电路交换网络：电话网络
电路交换的三个阶段：
- 1.建立连接（呼叫/电路建立）
- 2.通信
- 3.释放连接（拆除电路）

### 电路交换网络中的中继线
多路复用技术

![](https://github.com/w771854332/bengiBlog-node/blob/master/public/screenshot/多路复用.png?raw=true)

- 1.将链路网络资源（如带宽）划分为“资源片”
- 2.将资源片分配给各路“呼叫”calls
- 3.将每路呼叫独占分配到的资源片进行通信
- 4.资源片竟可能的“闲置”idle

典型的多路复用方法：
- 1.频分复用（Frequency Division Multiplexing）
将频率纵向划分成n个频带，用户在分配到这个频带后，始终占用这个频带，互不干扰。
缺点：不太灵活
- 2.时分复用（Time Division Multiplexing）

将时间片划分成一段段等长的帧，每个用户在每个TDM帧上占用固定序号的时隙。每个用户所占用的时隙是周期性出现。  类似于时间片轮转的机制。
缺点
- 3.波分复用（按照光的波长进行划分）
在光通信系统中的频分复用，称为波分复用

- 4.码分复用（Code Division Multiplexing）

广泛应用于 蜂窝网，卫星通信
为每个用户分配一个唯一的码分序列，各用户使用各自的身份码分序列对数据进行编码。每个用户占用的频率是相同的

为保证每个用户的数据在相同频率上传输互不干扰。

码片序列需要互相正交

> 电路交换的特点：独占资源

2.报文交换（message switching）

3.分组交换（package switching）
- 分组：报文分拆出来的一系列相对较小的数据包
- 需要报文的拆分与重组
- 会产生额外的开销

```bash
  [头][ 数据 ]
  进行分组
```

运行步骤：
1.在源主机对报文进行拆分，分组
2.源主机一个分组一个分组进行转发。当中间路由器向目的主机进行转发分组时，源主机进行下一个分组的发送
3.发送完毕后，目的主机对所有分组进行组装，得到原始报文

#### 分组交换网络，是如何共享链路的
统计多路复用 （Statistical Multiplexing）
存储-转发（store-and-forward）
报文交换与分组交换 存采用转储-转发的交换方式。

区别：
报文交换以**完整的报文**进行“转储-转发”
分组交换以**较小的分组**进行“存储-转发”

#### 分组交换 vs 报文交换

0————R————R————R—————D

报文交换：
- 报文长度：Mbits
- 链路带宽为：Rbps
- 每次传输报文需要：M/R秒


分组交换：
每个路由器节点，可以并行的转发分组
- 报文被拆分为多个分组
- 分组的长度为：Lbits
- 每个分组传输时延为：L/Rs
- 路由器数量：n

T=M/R+nL/R
分组交换的交付时间相比 报文交换 大大降低

### 分组交换 的拥塞现象




### 服务 下层对上层提供



## OSI/RM 七层模型

```
应用层          应用层
表示层
会话层
传输层          传输层  为主机中的进程通信提供服务
网络层          网络层  为网络主机通信提供分组传输服务，传输的基本单位是 分组（ip数据报）。另外一个重要的作用，路由选择
数据链路层       数据链路层 封装成帧 透明传输 差错检验
物理层          物理层 传输基本单位 比特流
```

![](https://github.com/w771854332/bengiBlog-node/blob/master/public/screenshot/发送数据.png?raw=true)

#### qq从主机甲向主机乙发送数据经历的过程

在数据链路层 插入首部和尾部，在每经过一个层次模型后，添加上该层的标记。


## TCP、IP体系结构
允许跨层，减少开销，增加协议的效率
```
  应用层
  传输层
  网络层
  网络接口层
```
网络层方案

路由选择


### https原理
就是在简历安全通道的前提下运行http协议





#### MAC地址

每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是**48个二进制位**

数据链路层如何直接进行通信，可以通过一个子网中的广播来实现。
- 一块网卡如何知道另一块网卡的mac地址？
若处在相同子网中，以太网网桥（桥接器）会进行广播，让一个子网中的所有主机都接收到数据包，进行自行判断。
缺点：

  - 1.效率低
  - 2.局限在同一个子网中

#### 网络层的由来

- 计算机需要进行高效的跨子网的通信，能够区分不同的计算机是否属于同一个子网络。IP

于是，"网络层"出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。

网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。

##### ip、子网掩码subnet mask
若两个主机处于同一个子网中，可以直接计算ip和子网掩码的AND运算，判断是否相同即可。

网络层的**IP**数据包在发送时，包括
```
  [HEAD][DATA]
```
两部分，然后IP数据包被封装在以太网数据包中
```
  [HEAD][HEAD][DATA]
```
层层包裹，就像俄罗斯套娃一样。

##### 网络层通过ip协议的数据通信
因为ip数据包被封装在以太网数据包中，该数据包中不包含MAC地址。网络层只向上提供数据报服务，不管正确与否。他都会走到向下的数据链路层。
这个时候，因为以太网数据包中不包含MAC地址，而数据链路层的通信必须要MAC地址。
于是就有了 ARP(地址解析协议)。
- 1.若目的主机不与源主机处于同一子网络，则直接把数据报交给连接处的“网关”
  - 1.操作系统层面只认识IP地址，MAC地址等被封装在机器内部。
  - 2.操作系统中配置好了网关的地址，凡是操作系统发现不在“掩码”范围内的值，通通发给gateway....不管gateway是否真的存在。
    gateway在收到ip数据包后，会根据自己内部的路由表继续寻找目的机器的方向。
- 2.若处于同一子网络，则命中ARP协议。源主机先在自己的APR缓存表中寻找是否有目标ip地址。若找到则直接写入帧中发送。若找不到，就会发送一个广播。


##### 传输层的由来
***建立端到端通信（端口到端口）***
为了便于计算机进行区分，互联网上发来的数据包，到底应该给主机上哪个进程使用。

端口（port）类似一间房子上很多扇窗户。他是0-65535之间的整数。表示房子（主机）里的进程和外界通信的入口。

有了端口 + 主机（socket）套接字，就能够进行准确的程序与程序之间的通信。

##### 其中就包括UDP和TCP

##### 应用层的作用，规定数据格式
[点我](http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html)






#### SSL(Secure Socket Layer)协议的基本运行过程
[点我](https://segmentfault.com/a/1190000002554673)

SSL握手协议对应会话层， SSL记录协议对应表示层
Handshake Protocol 用来协商秘钥，和Record Protocol定义传输格式
```
1.客户端向服务器索要并验证公钥。clientHello{
  1.支持的协议版本
  2.客户端生成的随机数，用于稍后生成“对话秘钥”
  3.支持的加密算法，比如RSA公钥加密
  4.支持的压缩方法
}
2.服务器下发 serverHello{
  1.确认使用的加密通信协议版本
  2.服务器生成的随机数，用于稍后生成“对话秘钥”
  3.确认使用的加密方法，如RSA公钥加密
  4.服务器证书{
    身份
    公钥
  }
}
3.客户端回应（Certificate Verify）{
  1.Client Key Exchange{
    向服务端发送客户端的证书，让服务端验证合法性
  }
  2.Certificate Verify， 客户端对服务端的证书进行检查（是否是可信机构颁发的，证书中的域名是否和实际一致。证书是否过期），over后客户端取出证书中的服务器公钥{
    1.发送随机数。用于服务器公钥加密。
    2.编码改变通知，表示随后的信息都用双方商定的加密方式和密钥发送
    3.客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来提供服务器校验。
  }
  3.ChangeCipherSpec，他是一个独立协议，体现在数据包中就是一个字节的数据，用于告知服务器。客户端已经切换到之前商量好的加密套件状态，准备使用之前协商好的加密套件加密数据并传输了。
  4.Server Finish，  服务端在接收到客户端传过来的PreMaster加密数据之后，使用私钥对着端{

  }
}
```
SSL客户端（也是TCP的客户端）在TCP链接建立之后，发出一个ClientHello来发起握手，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL的服务器端会回应一个ServerHello，这里面确定了这次通信所需要的算法，然后发过去自己的证书（里面包含了身份和自己的公钥）。Client在收到这个消息后会生成一个秘密消息，用SSL服务器的公钥加密后传过去，SSL服务器端用自己的私钥解密后，会话密钥协商成功，双方可以用同一份会话密钥来通信了。

- 1）如何保证公钥不被篡改？

解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

- （2）公钥加密计算量太大，如何减少耗用的时间？

解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

